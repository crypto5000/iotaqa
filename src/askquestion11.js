$(document).ready(function() {

    let question = "";
    let bounty = 0;    
    let viewAddress = "";    

    // check that curl library is supported with webgl2
    try{
        curl;
        
        // get the address question, bounty from localstorage
        question = localStorage.getItem("question");
        bounty = localStorage.getItem("bounty");
        viewAddress = localStorage.getItem("qAddress");
        
        // convert bounty to number
        bounty = parseInt(bounty);            

        // clear the localstorage for future use        
        window.localStorage.clear();

        // check if field has a question
        if (!question) {
            alert("Question is invalid. Please enter a value.");                                        
            return false;
        }

        // validate the question length
        if (question.length > 750) {
            alert("Question is invalid. Question should be less than 750 characters.");                                        
            return false;
        }

        // check if field has a bounty
        if (!bounty) {
            alert("Bounty is invalid. Please enter a value.");                                        
            return false;
        }

        // check if field has a number bounty
        if (isNaN(bounty)) {
            alert("Bounty is invalid. Please enter a value.");                                        
            return false;
        }

        // validate the bounty
        if ((bounty < 1) || (bounty > 100000000000000000)) {
            alert("Bounty is invalid. Bounty should be between 1 and 100000000000000000.");                                        
            return false;
        }
        
        // check if field has an address
        if (!viewAddress) {
            alert("Address is invalid. Please enter a value.");                                        
            return false;
        }

        // validate the address length             
        if (viewAddress.length !== 90) {
            alert("Address is invalid. Addresses should be 90 characters.");                                        
            return false;
        }

        // validate the address content
        for (var j = 0; j < viewAddress.length; j++) {
            if (("9ABCDEFGHIJKLMNOPQRSTUVWXYZ").indexOf(viewAddress.charAt(j)) < 0) {                            
                alert("Address should contain only letters A-Z or the number 9. Address is invalid.");                                        
                return false;
            }
        }

        // start the send process
        askQuestion(question,bounty);

    } catch(err){
        console.log("curl not supported",err);            
        alert("Webgl2 browser required to ask question. Try desktop Firefox or Chrome.");
        return false;
    }

    function askQuestion(question,bounty) {
                        
        // create a list of https nodes
        let hostHttps = ['https://nodes.iota.cafe', 'https://iotanode.prizziota.com'];
        let portHttps = [443, 443];

        // initialize host and port
        let host = hostHttps[0];
        let port = portHttps[0];

        // pull a random https node to rotate usage (if nodes.iota gets overloaded)
        if (Math.random() > 1) {
            host = hostHttps[1];
            port = port[1];
        }

        // initialize curl library values
        curl.init();
        const MAX_TIMESTAMP_VALUE = (Math.pow(3,27) - 1) / 2;

        // instantiate IOTA object
        var iota = new IOTA({
            'host': host,
            'port': port        
        });                                                            
                                        
        // initialize transfer data
        let seed = generateSeed();
        let value = 0;             
        let message = bounty + " IOTAS" + " " + question;
        let tag = "IOTAQNAQQQQQQQQQQQQQQQQQQQA";                       
        let depth = 10;
        let weight = 14;
        
        // WARNING: Not cryptographically secure. Do not use any seeds generated by this generator to actually store any value.
        function generateSeed() {
            const validChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ9';
            return Array.from(new Array(81), (x, i) => validChars[Math.floor(Math.random() * validChars.length)]).join('');
        }

        // returns a depth in [4, 12] inclusive
        function generateDepth() {
            depth = Math.floor(Math.random() * (12 - 4 + 1)) + 4;
            return depth;
        }

        // adapted from https://github.com/iotaledger/wallet/blob/master/ui/js/iota.lightwallet.js
        const localAttachToTangle = function(trunkTransaction, branchTransaction, minWeightMagnitude, trytes, callback) {

            $('#loadingText').html("Attaching Question to Tangle");		

            const ccurlHashing = function(trunkTransaction, branchTransaction, minWeightMagnitude, trytes, callback) {
                const iotaObj = iota;

                $('#loadingText').html("Now Starting Curl Hashing");	                        
                
                // inputValidator: Check if correct hash
                if (!iotaObj.valid.isHash(trunkTransaction)) {
                    return callback(new Error("Invalid trunkTransaction"));
                }

                // inputValidator: Check if correct hash
                if (!iotaObj.valid.isHash(branchTransaction)) {
                    return callback(new Error("Invalid branchTransaction"));
                }

                // inputValidator: Check if int
                if (!iotaObj.valid.isValue(minWeightMagnitude)) {
                    return callback(new Error("Invalid minWeightMagnitude"));
                }

                let finalBundleTrytes = [];
                let previousTxHash;
                let i = 0;

                function loopTrytes() {
                    getBundleTrytes(trytes[i], function(error) {
                        if (error) {
                            return callback(error);
                        } else {
                            i++;
                            if (i < trytes.length) {
                                loopTrytes();
                            } else {
                                // reverse the order so that it's ascending from currentIndex
                                return callback(null, finalBundleTrytes.reverse());
                            }
                        }
                    });
                }

                function getBundleTrytes(thisTrytes, callback) {
                    // PROCESS LOGIC:
                    // Start with last index transaction
                    // Assign it the trunk / branch which the user has supplied
                    // IF there is a bundle, chain  the bundle transactions via
                    // trunkTransaction together

                    let txObject = iotaObj.utils.transactionObject(thisTrytes);
                    txObject.tag = txObject.tag || txObject.obsoleteTag;
                    txObject.attachmentTimestamp = Date.now();
                    txObject.attachmentTimestampLowerBound = 0;
                    txObject.attachmentTimestampUpperBound = MAX_TIMESTAMP_VALUE;
                    // If this is the first transaction, to be processed
                    // Make sure that it's the last in the bundle and then
                    // assign it the supplied trunk and branch transactions
                    if (!previousTxHash) {
                        // Check if last transaction in the bundle
                        if (txObject.lastIndex !== txObject.currentIndex) {
                            return callback(new Error("Wrong bundle order. The bundle should be ordered in descending order from currentIndex"));
                        }

                        txObject.trunkTransaction = trunkTransaction;
                        txObject.branchTransaction = branchTransaction;
                    } else {
                        // Chain the bundle together via the trunkTransaction (previous tx in the bundle)
                        // Assign the supplied trunkTransaciton as branchTransaction
                        txObject.trunkTransaction = previousTxHash;
                        txObject.branchTransaction = trunkTransaction;
                    }

                    let newTrytes = iotaObj.utils.transactionTrytes(txObject);

                    curl.pow({trytes: newTrytes, minWeight: minWeightMagnitude}).then(function(nonce) {
                        var returnedTrytes = newTrytes.substr(0, 2673-81).concat(nonce);
                        var newTxObject= iotaObj.utils.transactionObject(returnedTrytes);

                        // Assign the previousTxHash to this tx
                        var txHash = newTxObject.hash;
                        previousTxHash = txHash;

                        finalBundleTrytes.push(returnedTrytes);
                        callback(null);
                    }).catch(callback);
                }
                loopTrytes()
            }

            ccurlHashing(trunkTransaction, branchTransaction, minWeightMagnitude, trytes, function(error, success) {
                if (error) {
                    console.log(error);
                    $('#loadingText').html("Hashing error. Try Starting Over.");	                            
                } else {
                    console.log(success);
                    $('#loadingText').html("Hashing Succeeded. Let's Move On.");	
                }
                if (callback) {
                    return callback(error, success);
                } else {
                    return success;
                }
            })
        }

        sendMessages(viewAddress);                        
        
        function sendMessages(viewAddress) {

            // using this because of bug with using curl.overrideAttachToTangle()
            iota.api.attachToTangle = localAttachToTangle;
            
            // bundle the transfers for all the tasks 
            let transfers = [];                    

            transfers.push({
                address: viewAddress,
                value: value,
                message: iota.utils.toTrytes(message),
                tag: tag
            });
                                    
            $('#loadingText').html("Doing PoW (Proof of Work)");	
            iota.api.sendTransfer(seed, generateDepth(), weight, transfers, function(error, success){
                if (error) {
                    console.log("error in send transfer, api could be down",error);
                    $('#loadingText').html("Error Sending Transfer. Try Starting Over.");	
                    alert("Public Node Could Be Down. Try Again Later.");
                    return
                }
                console.log("completed proof of work and sent",success);                        
                                
                // show the display message
                $('#address').text(viewAddress);	
                $('#loading').hide();
                $('#loadingText').html("Success. Question is Now In the Tangle.");	
                $('#breakGap').hide();	
                $('#displaySuccess').show();	

            })
        }
        
    }
    
    return false;

});  	                                     
